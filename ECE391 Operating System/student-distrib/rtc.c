#include "rtc.h"

//volatile static uint32_t req_freq = 0;
//static uint32_t count = 0;
/////////// Referenced From /////////////////
/* https://wiki.osdev.org/RTC */ 


/* Flags for RTC interrupts */
volatile static int8_t RTC_IRQF = 0;
static int8_t rtc_devices;

/* Functions to enable and disable NMI */
static void NMI_enable();
static void NMI_disable();

/* Helper funtion to test for rtc_open and rtc_write */
//static void rtc_open_write_test();

/* 
 * rtc_init
 *   DESCRIPTION: Initialize rtc.
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: Writes to rtc registers.
 */
void rtc_init(){
	
	/* Make a critical section  */
	cli();

	int32_t i = 0;

	for(i = 0; i < MAX_NUM_TERMINALS; i++){
		terminal_arr[i].count = 0;
		terminal_arr[i].req_count = 0;
	}

	rtc_devices = 1;

	/* Disable Non-maskable interrupt, so that rtc doesn't interrupt itself. */
	NMI_disable();

	/* Start sending interrupt periodically */
	outb(REG_B, REG_NUM);
	uint8_t prev = inb(REG_DATA);
	outb(REG_B, REG_NUM);
	outb(MASK_7 | prev, REG_DATA);
	
	/* Enable back non-maskable interrupt */
	NMI_enable();
	sti();

	/* Enable the IRQ for RTC on the 8259 PIC */
	enable_irq(RTC_IRQ);
}

/* 
 * rtc_open -----FUNCTION IS INCOMPLETE-----
 *   DESCRIPTION:
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: 
 *   SIDE EFFECTS: Sets the frequency of RTC periodic interrupts to 2 Hz.
 */
int32_t rtc_open(const uint8_t* filename){
	
	/* Set rate val to 15 to get a frequency of 2 Hz */
	uint32_t rate_val = TWO_HZ_FIFTEEN;
	//uint32_t rate_val = RTC6;

	int i;
	/* check if any terminal programs are using rtc, if yes, then set rate to highest, otherwise, keep default 2Hz */
	for (i = 0; i < MAX_NUM_TERMINALS; i++){
		if (terminal_arr[i].req_count){
			rate_val = RTC6;
			if (rtc_devices < 3)
				rtc_devices++;
			break;
		}
	}
	
	cli();

	/* Disable Non-maskable interrupt, so that rtc doesn't interrupt itself. */
	NMI_disable();
	
	outb(REG_A, REG_NUM);	/* Select register A */
	uint8_t prev = inb(REG_DATA);
	
	outb(REG_A, REG_NUM);
	outb((prev & MASK_4_BITS_1) | rate_val, REG_DATA);	/* Write the updated rate to register A */
	
	/* Enable back non-maskable interrupt */
	NMI_enable();
	sti();

	return 0;
}

/* 
 * rtc_close -----FUNCTION IS INCOMPLETE-----
 *   DESCRIPTION:
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: Returns 0 on success.
 *   SIDE EFFECTS: none
 */
int32_t rtc_close(int32_t fd){
	/*For now should always return 0 (Checkpoint 2)*/
	if (rtc_devices > 1)
		rtc_devices--;
	return 0;
}

/* 
 * rtc_read
 *   DESCRIPTION: Read from RTC. Return if interrupt is generated by the RTC.
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: Always returns 0 for success.
 *   SIDE EFFECTS: Changes local flag RTC_IRQF.
 */
int32_t rtc_read(int32_t fd, void* buf, int32_t nbytes){
	
	terminal_arr[get_cur_terminal()-1].count = 0;
	RTC_IRQF = 0;
	while(RTC_IRQF != 1);

	return 0;
}

/* 
 * rtc_write
 *   DESCRIPTION: Change the frequency of the RTC periodic interrupts.
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: Returns the number of bytes written (always 1 in this case). Returns -1 on failure.
 *   SIDE EFFECTS: Changes the frequency of periodic interrupts of the RTC.
 */
int32_t rtc_write(int32_t fd, const void* buf, int32_t nbytes){

	if(buf == NULL) return -1;
	
	//uint8_t rate_val = 0;
	// uint32_t cur_rate = RTC_FIRST_USABLE_FREQ;
	// uint32_t prev_rate = RTC_FIRST_USABLE_FREQ << 1;

	//uint32_t check_freq;
	uint32_t freq = *(uint32_t *)buf;
	
	/* Parameter check */
	if(freq > HIGHEST_ALLOWED_FREQ || freq < LOWEST_ALLOWED_FREQ){
		return -1;
	}

	// if(1024 >= freq*3){
	// 	terminal_arr[get_cur_terminal()-1].req_count = RTC1024/(freq*3);
	// }else{
	// 	terminal_arr[get_cur_terminal()-1].req_count = 1;
	// }
	// check_freq = freq-1;
	// if((freq & check_freq) != 0) {
	// 	return -1;
	// }

	/* when more devices use rtc, emulate higher frequency to make up for performance */
	if(RTC1024 >= freq){
		terminal_arr[get_cur_terminal()-1].req_count = RTC1024/(freq*rtc_devices);
	}else{
		/* freq > 1024Hz, emulate 1024Hz */
		terminal_arr[get_cur_terminal()-1].req_count = 1;
	}

	
	/* Find the rate value to write to register A corresponding to given frequency */
	
	//Daksh - value for rate_val was off by 1, fixed it

	/*     
	*	rate_val -> rate (Hz)
	*	15 	->	2
	*	14	->	4
	*	13	->	8
	*	12	->	16
	*	11	->	32
	*	10	->	64
	*	 9	->	128
	*	 8	->	256
	*	 7	->	512
	*	 6	->	1024

	*   Example: if rate = 512, we want rate_val to be 7
	*   The following while loop will do something like this:
	*   curr_rate	prev_rate	rate_val
	*	8192		16384		0	(at the start of while loop)
	*	4096		8192		1
	*	2048		4096		2
	*	1024		2048		3
	*	 512		1024		4
	*	 256		 512		5
	* 	At this point, we will exit from the for loop with rate_val = 5 , adding 2 to it will
	*	give us the value of 7 which we want
	*/
	
	/* The rate to be written must be between 6 (1024 Hz) to 15 (2 Hz) (both included).
	This is an extra check just in case.*/

	// if(freq == RTCDOUBLE){rate_val = RTC15;}
	// else if(freq == RTC4){rate_val = RTC14;}
	// else if(freq == RTC8){rate_val = RTC13;}
	// else if(freq == RTC16){rate_val = RTC12;}
	// else if(freq == RTC32){rate_val = RTC11;}
	// else if(freq == RTC64){rate_val = RTC10;}
	// else if(freq == RTC128){rate_val = RTC9;}
	// else if(freq == RTC256){rate_val = RTC8;}
	// else if(freq == RTC512){rate_val = RTC7;}
	// else if(freq == RTC1024){rate_val = RTC6;}

	/* Start critical section to write to RTC */
	cli();

	/* Disable Non-maskable interrupt, so that rtc doesn't interrupt itself. */
	NMI_disable();
	
	outb(REG_A, REG_NUM);	/* Select register A */
	uint8_t prev = inb(REG_DATA);
	
	outb(REG_A, REG_NUM);
	outb((prev & MASK_4_BITS_1) | RTC6, REG_DATA);	/* Write the updated rate to register A */
	
	/* Enable back non-maskable interrupt */
	NMI_enable();
	sti();
	

	//Daksh - changed it to 0 as the documentation said that (0) is success
	return 0; /* Return 1 to indicate 1 byte written to RTC */
}

/* 
 * rtc_interrupt
 *   DESCRIPTION: Interrupt handler for RTC. Calls test_interrupts provided in lib.c.
 *   INPUTS: none
 *   OUTPUTS: Shifts screen by one character.
 *   RETURN VALUE: none
 *   SIDE EFFECTS: Modifies video memory.
 */

void rtc_interrupt(){
	/* Send End of Interrupt to indicate interrupt handled */
	send_eoi(RTC_IRQ);
	
	/* Make a critical section so that the handler is not interrupted by another interrupt. */
	cli();

	/* increment count of rtc_Interrupts for terminal */
	terminal_arr[get_cur_terminal()-1].count++;

	/* if counts are the same, allow interrupt to go through */
	if(terminal_arr[get_cur_terminal()-1].count == terminal_arr[get_cur_terminal()-1].req_count){ // -1
		/* Set interrupt flag */
		terminal_arr[get_cur_terminal()-1].count = 0;
		RTC_IRQF = 1;
	}
	/* if no terminals are using rtc let interrupt through */
	else if(!terminal_arr[get_cur_terminal()-1].req_count){ 
		terminal_arr[get_cur_terminal()-1].req_count = RTC1024/FREQ_SCALE;
		/* Set interrupt flag */
		RTC_IRQF = 0;
	}
	/* if programs using rtc and count is not equal, then don't allow interrupt */
	else {
		/* Set interrupt flag */
		RTC_IRQF = 0;
	}
	

	/*Call RTC Open Write Tests*/
	//rtc_open_write_test();

	/* Call test_interrupts provided in lib.c. */
	//test_interrupts();

	/* Acknowledge interrupt accepted from RTC. */
	outb(REG_C, REG_NUM);
	inb(REG_DATA);
	
	sti();
}

/* 
 * NMI_disable
 *   DESCRIPTION: Disables Non-Maskable Interrupt (NMI).
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: none
 */
static void NMI_disable(){
	uint8_t current = inb(REG_NUM);
	current = current | MASK_8; /* Set the 8th bit */
	outb(current, REG_NUM);
}

/* 
 * NMI_enable
 *   DESCRIPTION: Enables Non-Maskable Interrupt (NMI).
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: none
 */
static void NMI_enable(){
	uint8_t current = inb(REG_NUM);
	current = current & UNMASK_8; /* Unset the 8th bit */
	outb(current, REG_NUM);
}

/* 
 * rtc_open_write_test
 *   DESCRIPTION: Open/Write Test
 *   INPUTS: none
 *   OUTPUTS: none
 *   RETURN VALUE: none
 *   SIDE EFFECTS: none
 */
// static int count = 0;
// static void rtc_open_write_test(){
// 	putc('1');
// 	if(count == RTCCOUNT){
// 		putc('\n');
// 		count = 0;
// 	}
// 	count += 1;
// }

